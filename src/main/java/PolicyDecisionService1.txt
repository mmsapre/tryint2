package com.mmsapre.semantic.engine;

import com.mmsapre.semantic.config.PolicyProperties;
import com.mmsapre.semantic.graph.GraphPolicyEngine;
import com.mmsapre.semantic.intent.CompositeIntentClassifier;
import com.mmsapre.semantic.model.*;
import com.mmsapre.semantic.store.AuditDao;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.regex.Pattern;

@Component
public class PolicyDecisionService {

  private final PolicyProperties props;
  private final CompositeIntentClassifier intentClassifier;
  private final GraphPolicyEngine graphPolicy;
  private final EntitlementPolicyEngine entitlementPolicy;
  private final TagPolicyEngine tagPolicy;
  private final AuditDao audit;

  public PolicyDecisionService(PolicyProperties props,
                               CompositeIntentClassifier intentClassifier,
                               GraphPolicyEngine graphPolicy,
                               EntitlementPolicyEngine entitlementPolicy,
                               TagPolicyEngine tagPolicy,
                               AuditDao audit) {
    this.props = props;
    this.intentClassifier = intentClassifier;
    this.graphPolicy = graphPolicy;
    this.entitlementPolicy = entitlementPolicy;
    this.tagPolicy = tagPolicy;
    this.audit = audit;
  }

  public AuthorizationDecision decide(SubjectContext subject, RequestFacts facts) {

    // Derive entityType from dataset (UI config can make this explicit; demo does simple mapping)
    String entityType = guessEntityType(facts.dataset());

    // 1) ENTITLEMENTS (highest precedence)
    EntitlementDecision ed = entitlementPolicy.evaluate(subject, entityType, facts.entityId());
    if (ed.deny()) {
      AuthorizationDecision d = new AuthorizationDecision(false, false, false, ed.reason(), Map.of(), List.of(), null);
      audit.audit(facts.requestId(), d);
      return d;
    }

    // 2) TAGS (next precedence)
    TagDecision td = tagPolicy.evaluate(facts.dataset(), facts.entityId(), subject.platform());
    if (td.deny()) {
      AuthorizationDecision d = new AuthorizationDecision(false, false, false, td.reason(), Map.of(), List.of(), null);
      audit.audit(facts.requestId(), d);
      return d;
    }

    // 3) Intent
    IntentResult rawIntent = intentClassifier.classify(facts);

    // 4) Adaptive graph purpose degradation
    var go = graphPolicy.evaluatePurpose(subject.clientType(), rawIntent.purpose());
    IntentResult intent = new IntentResult(go.effectivePurpose(), rawIntent.confidence(),
        rawIntent.explanation() + " | " + go.note());

    // 5) Low confidence => pending approval (demo: block)
    if (intent.confidence() < props.getConfidenceThreshold()) {
      AuthorizationDecision d = new AuthorizationDecision(false, false, true, "lowConfidence", Map.of(), go.usedEdges(), intent);
      audit.audit(facts.requestId(), d);
      return d;
    }

    // 6) Build transforms
    Map<String, String> transforms = new HashMap<>();

    // entitlement says force mask all
    if (ed.forceMaskAll()) transforms.put("*", ObfuscationStrategy.REDACT.name());

    // tag says mask all
    if (td.forceMaskAll()) transforms.put("*", ObfuscationStrategy.REDACT.name());

    for (String key : facts.payloadKeys()) {
      FieldSemantics sem = classify(key);

      boolean allowed = graphPolicy.purposeAllowsFieldClass(intent.purpose(), sem.fieldClass());
      if (!allowed && props.getGraph().getDegradableDimensions().contains("FIELD_CLASS")) {
        transforms.put(key, ObfuscationStrategy.REDACT.name());
        continue;
      }

      String strat = props.getObfuscation().getStrategies().getOrDefault(sem.fieldClass(), "NONE");
      if (!"NONE".equalsIgnoreCase(strat)) transforms.put(key, strat.toUpperCase());
    }

    boolean obfuscate = !transforms.isEmpty();
    AuthorizationDecision d = new AuthorizationDecision(true, obfuscate, false, "allow", transforms, go.usedEdges(), intent);
    audit.audit(facts.requestId(), d);
    return d;
  }

  private String guessEntityType(String dataset) {
    if (dataset == null) return "UNKNOWN";
    if (dataset.contains("accounts")) return "ACCOUNT";
    if (dataset.contains("instruments")) return "INSTRUMENT";
    if (dataset.contains("party")) return "PARTY";
    if (dataset.contains("customer")) return "CUSTOMER";
    return "UNKNOWN";
  }

  private FieldSemantics classify(String key) {
    for (var r : props.getFieldRegistry()) {
      String re = r.getMatch().getPathRegex();
      if (re != null && Pattern.compile(re, Pattern.CASE_INSENSITIVE).matcher(key).matches()) {
        return new FieldSemantics(r.getSemantics().getFieldClass(), r.getSemantics().getSensitivity());
      }
    }
    return new FieldSemantics("derived", "LOW");
  }
}
